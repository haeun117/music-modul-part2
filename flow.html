<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Draw Chord</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .board { touch-action: none; }
    .toast { transition: opacity .15s ease, transform .15s ease; }
  </style>
</head>
<body class="min-h-screen bg-slate-100 text-slate-900">
  <main class="mx-auto w-full max-w-5xl p-4 md:p-6 space-y-4">
    <header class="rounded-2xl bg-white shadow p-4 flex flex-wrap items-center justify-between gap-3">
      <h1 class="text-xl font-semibold">Draw Chord</h1>
      <div class="flex flex-wrap items-center gap-2">
        <label class="flex items-center gap-2 rounded-full bg-slate-100 px-3 py-2 text-sm font-semibold">
          <span>Key</span>
          <select id="keySelect" class="rounded-full border border-slate-200 bg-white px-2 py-1 text-sm"></select>
        </label>
        <button id="soundToggle" class="rounded-full border border-slate-300 bg-white px-4 py-2 text-sm font-semibold">
          Sound ON
        </button>
        <button id="resetButton" class="rounded-full bg-slate-900 px-4 py-2 text-sm font-semibold text-white">
          Reset
        </button>
      </div>
    </header>

    <section class="flex flex-col items-center gap-3">
      <div class="relative w-full max-w-[560px] aspect-square rounded-2xl bg-white shadow border border-slate-200 overflow-hidden board" id="board">
        <div id="grid" class="absolute inset-0"></div>

        <svg id="svg" class="absolute inset-0 w-full h-full pointer-events-none" viewBox="0 0 520 520" preserveAspectRatio="none">
          <g id="committed"></g>
          <polyline id="active" fill="none" stroke="#0ea5e9" stroke-width="16" stroke-linecap="round" stroke-linejoin="round" points=""></polyline>
        </svg>

        <div id="nodes" class="absolute inset-0"></div>

        <div id="toast" class="toast absolute top-3 left-1/2 -translate-x-1/2 opacity-0 -translate-y-2 px-4 py-2 rounded-full bg-emerald-500 text-white text-sm font-semibold shadow">
          완성!
        </div>
      </div>

      <div class="w-full max-w-[560px] rounded-2xl bg-white shadow p-4 flex flex-wrap items-center justify-between gap-2 text-sm font-semibold">
        <div id="status" class="text-slate-600">노드에서 드래그를 시작해 연결하세요.</div>
        <div class="flex gap-2">
          <span class="rounded-full bg-slate-100 px-3 py-1">I <span id="cI">0</span></span>
          <span class="rounded-full bg-slate-100 px-3 py-1">IV <span id="cIV">0</span></span>
          <span class="rounded-full bg-slate-100 px-3 py-1">V <span id="cV">0</span></span>
        </div>
      </div>
    </section>
  </main>

<script>
  const keyNames = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
  const scaleIntervals = { do:0, re:2, mi:4, fa:5, sol:7, la:9, ti:11 };

  const nodesData = [
    { id:"do1", note:"do", label:"도", col:1, row:6, color:"#0ea5e9" },
    { id:"do2", note:"do", label:"도", col:6, row:6, color:"#0ea5e9" },
    { id:"re1", note:"re", label:"레", col:3, row:6, color:"#6366f1" },
    { id:"re2", note:"re", label:"레", col:6, row:3, color:"#6366f1" },
    { id:"mi1", note:"mi", label:"미", col:5, row:6, color:"#ec4899" },
    { id:"mi2", note:"mi", label:"미", col:1, row:1, color:"#ec4899" },
    { id:"fa1", note:"fa", label:"파", col:1, row:3, color:"#fb923c" },
    { id:"fa2", note:"fa", label:"파", col:5, row:1, color:"#fb923c" },
    { id:"sol1", note:"sol", label:"솔", col:3, row:3, color:"#22c55e" },
    { id:"sol2", note:"sol", label:"솔", col:7, row:4, color:"#22c55e" },
    { id:"la1", note:"la", label:"라", col:5, row:3, color:"#eab308" },
    { id:"la2", note:"la", label:"라", col:2, row:4, color:"#eab308" },
    { id:"ti1", note:"ti", label:"시", col:6, row:1, color:"#ef4444" },
    { id:"ti2", note:"ti", label:"시", col:7, row:1, color:"#ef4444" },
  ];

  const chordRules = [
    { id:"I",  msg:"으뜸화음 완성!", notes:["do","mi","sol"] },
    { id:"IV", msg:"버금딸림화음 완성!", notes:["fa","la","do"] },
    { id:"V",  msg:"딸림화음 완성!", notes:["sol","ti","re"] },
  ];

  const board = document.getElementById("board");
  const grid = document.getElementById("grid");
  const nodesLayer = document.getElementById("nodes");
  const active = document.getElementById("active");
  const committed = document.getElementById("committed");
  const toast = document.getElementById("toast");
  const statusEl = document.getElementById("status");
  const keySelect = document.getElementById("keySelect");
  const soundToggle = document.getElementById("soundToggle");
  const resetButton = document.getElementById("resetButton");
  const cI = document.getElementById("cI");
  const cIV = document.getElementById("cIV");
  const cV = document.getElementById("cV");

  function renderGrid(){
    grid.innerHTML = "";
    grid.className = "absolute inset-0 grid";
    grid.style.gridTemplateColumns = "repeat(8, 1fr)";
    grid.style.gridTemplateRows = "repeat(8, 1fr)";
    for(let i=0;i<64;i++){
      const cell = document.createElement("div");
      cell.className = "border border-slate-100";
      grid.appendChild(cell);
    }
  }

  const VB = 520, PAD = 42, CELL = (VB - PAD*2)/7;
  function gridToVB(col,row){ return { x: PAD + col*CELL, y: PAD + row*CELL }; }
  function boardPxToVB(px,py){
    const r = board.getBoundingClientRect();
    return { x:(px/r.width)*VB, y:(py/r.height)*VB };
  }
  function pointerToVB(e){
    const r = board.getBoundingClientRect();
    return boardPxToVB(e.clientX-r.left, e.clientY-r.top);
  }
  function vbToPercent(v){ return (v/VB)*100; }

  const centers = {};
  nodesData.forEach(n => centers[n.id] = gridToVB(n.col,n.row));

  function renderNodes(){
    nodesLayer.innerHTML = "";
    nodesData.forEach(n=>{
      const c = centers[n.id];
      const btn = document.createElement("button");
      btn.className = "absolute flex h-12 w-12 md:h-14 md:w-14 items-center justify-center rounded-full text-white font-bold shadow select-none";
      btn.style.left = vbToPercent(c.x) + "%";
      btn.style.top  = vbToPercent(c.y) + "%";
      btn.style.transform = "translate(-50%,-50%)";
      btn.style.background = n.color;
      btn.dataset.id = n.id;
      btn.dataset.note = n.note;
      btn.textContent = n.label;
      nodesLayer.appendChild(btn);
    });
  }

  let audioCtx=null, soundOn=true, currentKey="C", freqs={};
  function ensureAudio(){
    if(!soundOn) return;
    if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    if(audioCtx.state==="suspended") audioCtx.resume();
  }
  function midiToFreq(m){ return 440*Math.pow(2,(m-69)/12); }
  function updateFreqs(){
    const keyIndex = keyNames.indexOf(currentKey);
    const baseMidi = 60 + keyIndex;
    freqs = {};
    Object.keys(scaleIntervals).forEach(k=>{
      freqs[k] = midiToFreq(baseMidi + scaleIntervals[k]);
    });
  }
  function playTone(note, dur=0.12, g=0.18){
    if(!soundOn) return;
    ensureAudio(); if(!audioCtx) return;
    const now = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type="sine"; osc.frequency.value=freqs[note];
    gain.gain.value=0.0001;
    osc.connect(gain); gain.connect(audioCtx.destination);
    gain.gain.exponentialRampToValueAtTime(g, now+0.02);
    gain.gain.exponentialRampToValueAtTime(0.0001, now+dur);
    osc.start(now); osc.stop(now+dur+0.05);
  }
  function playChord(notes){ notes.forEach(n=>playTone(n,0.45,0.14)); }

  const SNAP_R = 28;
  let drawing=false, pathNodeIds=[], pathNotes=[], points=[];
  let counts={I:0,IV:0,V:0};

  function setStatus(t){ statusEl.textContent=t; }
  function showToast(text, ok=true){
    toast.textContent=text;
    toast.style.background = ok ? "#10b981" : "#64748b";
    toast.classList.remove("opacity-0","-translate-y-2");
    toast.classList.add("opacity-100","translate-y-0");
    clearTimeout(showToast._t);
    showToast._t = setTimeout(()=>{
      toast.classList.add("opacity-0","-translate-y-2");
      toast.classList.remove("opacity-100","translate-y-0");
    }, 1000);
  }
  function updateActive(){ active.setAttribute("points", points.map(p=>`${p.x},${p.y}`).join(" ")); }
  function clearActive(){ pathNodeIds=[]; pathNotes=[]; points=[]; updateActive(); }

  function commitLine(color="#94a3b8"){
    if(points.length<2) return;
    const pl = document.createElementNS("http://www.w3.org/2000/svg","polyline");
    pl.setAttribute("fill","none");
    pl.setAttribute("stroke",color);
    pl.setAttribute("stroke-width","16");
    pl.setAttribute("stroke-linecap","round");
    pl.setAttribute("stroke-linejoin","round");
    pl.setAttribute("points", points.map(p=>`${p.x},${p.y}`).join(" "));
    committed.appendChild(pl);
  }

  function nearestNode(vb){
    let best=null, bestD=Infinity;
    for(const n of nodesData){
      const c=centers[n.id];
      const d=Math.hypot(vb.x-c.x, vb.y-c.y);
      if(d<bestD){ bestD=d; best=n; }
    }
    if(best && bestD<=SNAP_R) return { node:best, center:centers[best.id] };
    return null;
  }

  function checkChords(){
    const set = new Set(pathNotes);
    return chordRules.filter(r=>r.notes.every(n=>set.has(n)));
  }

  function updateCounters(){
    cI.textContent=counts.I; cIV.textContent=counts.IV; cV.textContent=counts.V;
  }

  board.addEventListener("pointerdown",(e)=>{
    ensureAudio();
    drawing=false;
    const vb = pointerToVB(e);
    const snap = nearestNode(vb);
    if(!snap) return;

    drawing=true;
    try{ board.setPointerCapture(e.pointerId);}catch(_){}

    clearActive();
    pathNodeIds.push(snap.node.id);
    pathNotes.push(snap.node.note);
    points=[snap.center, snap.center];
    active.setAttribute("stroke", snap.node.color);
    updateActive();
    playTone(snap.node.note,0.12);
    setStatus("연결 중… 노드로 이어보세요");
  });

  board.addEventListener("pointermove",(e)=>{
    if(!drawing) return;
    const vb = pointerToVB(e);
    points[points.length-1]=vb;
    updateActive();

    const snap = nearestNode(vb);
    if(!snap) return;
    if(!pathNodeIds.includes(snap.node.id)){
      pathNodeIds.push(snap.node.id);
      pathNotes.push(snap.node.note);
      points[points.length-1]=snap.center;
      points.push(snap.center);
      updateActive();
      playTone(snap.node.note,0.12);
    }
  });

  function endStroke(){
    if(!drawing) return;
    drawing=false;

    const matched = checkChords();
    if(matched.length){
      const first=matched[0];
      counts[first.id]+=1;
      updateCounters();
      showToast(first.msg,true);
      playChord(first.notes);
      commitLine("#0ea5e9");
      setStatus("화음 완성! 계속 이어서 만들어보세요.");
    }else{
      commitLine("#94a3b8");
      setStatus("노드에서 드래그를 시작해 연결하세요.");
    }
    clearActive();
  }

  board.addEventListener("pointerup", endStroke);
  board.addEventListener("pointercancel", endStroke);
  board.addEventListener("pointerleave", endStroke);

  function populateKeys(){
    keySelect.innerHTML="";
    keyNames.forEach(k=>{
      const opt=document.createElement("option");
      opt.value=k; opt.textContent=k;
      keySelect.appendChild(opt);
    });
    keySelect.value=currentKey;
  }

  soundToggle.addEventListener("click",()=>{
    soundOn=!soundOn;
    soundToggle.textContent = soundOn ? "Sound ON" : "Sound OFF";
  });

  keySelect.addEventListener("change",(e)=>{
    currentKey=e.target.value;
    updateFreqs();
    showToast(`Key: ${currentKey}`, false);
  });

  resetButton.addEventListener("click",()=>{
    committed.innerHTML="";
    clearActive();
    counts={I:0,IV:0,V:0};
    updateCounters();
    setStatus("노드에서 드래그를 시작해 연결하세요.");
    showToast("리셋!", false);
  });

  renderGrid();
  populateKeys();
  updateFreqs();
  renderNodes();
  updateCounters();
</script>
</body>
</html>
