 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/flow.html b/flow.html
index cdbbc9047011e772fefa7c5f16ef9f31409c1197..4ebff50041e6576e6a4d32037e2356eb8808441e 100644
--- a/flow.html
+++ b/flow.html
@@ -1,330 +1,522 @@
 <!doctype html>
 <html lang="ko">
   <head>
     <meta charset="utf-8" />
     <meta name="viewport" content="width=device-width, initial-scale=1" />
-    <title>Harmony Stack | Flow Free Chord</title>
+    <title>Draw Chord</title>
     <script src="https://cdn.tailwindcss.com"></script>
-    <script>
-      tailwind.config = {
-        theme: {
-          extend: {
-            colors: {
-              ink: "#0f172a",
-              surface: "#f8fafc",
-              mission: "#3b82f6"
-            },
-            borderRadius: {
-              "2xl": "1.25rem"
-            }
-          }
-        }
-      };
-    </script>
     <style>
       body {
         font-family: "Pretendard", "Inter", system-ui, sans-serif;
       }
       .board {
         touch-action: none;
+        --pad: 24px;
+        background-image:
+          linear-gradient(to right, rgba(148, 163, 184, 0.35) 1px, transparent 1px),
+          linear-gradient(to bottom, rgba(148, 163, 184, 0.35) 1px, transparent 1px);
+        background-size: calc((100% - (var(--pad) * 2)) / 7) calc((100% - (var(--pad) * 2)) / 7);
+        background-position: var(--pad) var(--pad);
+      }
+      .note {
+        transform: translate(-50%, -50%);
       }
     </style>
   </head>
-  <body class="min-h-screen bg-surface text-ink">
-    <main class="mx-auto flex w-full max-w-5xl flex-col gap-6 px-6 py-8">
-      <header class="flex flex-wrap items-center justify-between gap-4 rounded-2xl bg-white p-5 shadow-md">
-        <div>
-          <p class="text-sm font-semibold text-slate-500">Harmony Stack</p>
-          <h1 class="text-2xl font-bold">Flow Free 스타일 화음 연결</h1>
-        </div>
-        <div class="rounded-2xl border border-blue-100 bg-blue-50 px-4 py-3">
-          <p class="text-xs font-semibold text-blue-500">현재 미션</p>
-          <p class="text-sm font-semibold text-blue-600">
-            으뜸화음(I) 도-미-솔 연결
-          </p>
+  <body class="min-h-screen bg-slate-100 text-slate-900">
+    <main class="mx-auto flex w-full max-w-5xl flex-col gap-6 px-4 py-6">
+      <header class="flex flex-wrap items-center justify-between gap-4 rounded-2xl bg-white p-4 shadow">
+        <h1 class="text-xl font-semibold">Draw Chord</h1>
+        <div class="flex flex-wrap items-center gap-2">
+          <label class="flex items-center gap-2 rounded-full bg-slate-100 px-3 py-2 text-sm font-semibold">
+            <span>Key</span>
+            <select id="keySelect" class="rounded-full border border-slate-200 bg-white px-2 py-1 text-sm">
+            </select>
+          </label>
+          <button
+            id="soundToggle"
+            type="button"
+            class="rounded-full border border-slate-300 bg-white px-4 py-2 text-sm font-semibold"
+          >
+            Sound ON
+          </button>
+          <button
+            id="resetButton"
+            type="button"
+            class="rounded-full bg-slate-900 px-4 py-2 text-sm font-semibold text-white"
+          >
+            Reset
+          </button>
         </div>
       </header>
 
-      <section class="grid gap-6 lg:grid-cols-[2fr_1fr]">
-        <div class="flex flex-col items-center gap-4">
-          <div class="board relative w-full max-w-[520px] rounded-2xl bg-white p-4 shadow-lg">
-            <div class="grid grid-cols-6 gap-3">
-              <div class="cell aspect-square rounded-xl bg-slate-50"></div>
-              <div class="cell aspect-square rounded-xl bg-slate-50"></div>
-              <div class="cell aspect-square rounded-xl bg-slate-50"></div>
-              <div class="cell aspect-square rounded-xl bg-slate-50"></div>
-              <div class="cell aspect-square rounded-xl bg-slate-50"></div>
-              <div class="cell aspect-square rounded-xl bg-slate-50"></div>
-              <div class="cell aspect-square rounded-xl bg-slate-50"></div>
-              <div class="cell aspect-square rounded-xl bg-slate-50"></div>
-              <div class="cell aspect-square rounded-xl bg-slate-50"></div>
-              <div class="cell aspect-square rounded-xl bg-slate-50"></div>
-              <div class="cell aspect-square rounded-xl bg-slate-50"></div>
-              <div class="cell aspect-square rounded-xl bg-slate-50"></div>
-              <div class="cell aspect-square rounded-xl bg-slate-50"></div>
-              <div class="cell aspect-square rounded-xl bg-slate-50"></div>
-              <div class="cell aspect-square rounded-xl bg-slate-50"></div>
-              <div class="cell aspect-square rounded-xl bg-slate-50"></div>
-              <div class="cell aspect-square rounded-xl bg-slate-50"></div>
-              <div class="cell aspect-square rounded-xl bg-slate-50"></div>
-              <div class="cell aspect-square rounded-xl bg-slate-50"></div>
-              <div class="cell aspect-square rounded-xl bg-slate-50"></div>
-              <div class="cell aspect-square rounded-xl bg-slate-50"></div>
-              <div class="cell aspect-square rounded-xl bg-slate-50"></div>
-              <div class="cell aspect-square rounded-xl bg-slate-50"></div>
-              <div class="cell aspect-square rounded-xl bg-slate-50"></div>
-              <div class="cell aspect-square rounded-xl bg-slate-50"></div>
-              <div class="cell aspect-square rounded-xl bg-slate-50"></div>
-              <div class="cell aspect-square rounded-xl bg-slate-50"></div>
-              <div class="cell aspect-square rounded-xl bg-slate-50"></div>
-              <div class="cell aspect-square rounded-xl bg-slate-50"></div>
-              <div class="cell aspect-square rounded-xl bg-slate-50"></div>
-              <div class="cell aspect-square rounded-xl bg-slate-50"></div>
-              <div class="cell aspect-square rounded-xl bg-slate-50"></div>
-              <div class="cell aspect-square rounded-xl bg-slate-50"></div>
-              <div class="cell aspect-square rounded-xl bg-slate-50"></div>
-              <div class="cell aspect-square rounded-xl bg-slate-50"></div>
-              <div class="cell aspect-square rounded-xl bg-slate-50"></div>
-            </div>
-            <svg
-              id="lineLayer"
-              class="pointer-events-none absolute inset-0 h-full w-full"
-              viewBox="0 0 520 520"
-              preserveAspectRatio="none"
-            >
-              <polyline
-                id="flowLine"
-                fill="none"
-                stroke="#3b82f6"
-                stroke-width="16"
-                stroke-linecap="round"
-                stroke-linejoin="round"
-                points=""
-              ></polyline>
-            </svg>
-            <div
-              id="note-do"
-              data-note="do"
-              class="note absolute flex h-12 w-12 items-center justify-center rounded-full bg-blue-500 text-lg font-bold text-white shadow-md"
-              style="left: 10%; top: 20%;"
-            >
-              도
-            </div>
-            <div
-              id="note-mi"
-              data-note="mi"
-              class="note absolute flex h-12 w-12 items-center justify-center rounded-full bg-blue-500 text-lg font-bold text-white shadow-md"
-              style="left: 55%; top: 40%;"
-            >
-              미
-            </div>
-            <div
-              id="note-sol"
-              data-note="sol"
-              class="note absolute flex h-12 w-12 items-center justify-center rounded-full bg-blue-500 text-lg font-bold text-white shadow-md"
-              style="left: 72%; top: 70%;"
-            >
-              솔
-            </div>
-          </div>
-          <div
-            id="banner"
-            class="hidden rounded-full bg-slate-900 px-4 py-2 text-sm font-semibold text-white"
-          ></div>
+      <section class="flex flex-col items-center gap-4">
+        <div
+          id="board"
+          class="board relative aspect-square w-full max-w-[360px] rounded-2xl border border-slate-200 bg-white"
+        >
+          <svg
+            id="lineLayer"
+            class="pointer-events-none absolute inset-0 h-full w-full"
+            viewBox="0 0 520 520"
+            preserveAspectRatio="none"
+          >
+            <g id="committedLines"></g>
+            <polyline
+              id="activeLine"
+              fill="none"
+              stroke="#38bdf8"
+              stroke-width="16"
+              stroke-linecap="round"
+              stroke-linejoin="round"
+              points=""
+            ></polyline>
+          </svg>
+          <div id="nodesLayer" class="absolute inset-0"></div>
         </div>
-
-        <aside class="flex flex-col gap-4">
-          <div class="rounded-2xl bg-white p-5 shadow-md">
-            <h2 class="text-lg font-semibold">미션 진행</h2>
-            <p class="mt-2 text-sm text-slate-500">
-              도 → 미 → 솔 순서로 연결하면 성공합니다.
-            </p>
-            <ul class="mt-4 space-y-2 text-sm text-slate-600">
-              <li>시작: 도</li>
-              <li>다음: 미</li>
-              <li>마지막: 솔</li>
-            </ul>
-          </div>
-          <div class="rounded-2xl bg-white p-5 shadow-md">
-            <h2 class="text-lg font-semibold">조작 안내</h2>
-            <p class="mt-2 text-sm text-slate-500">
-              큰 터치 타겟으로 드래그를 지원합니다.
-            </p>
-          </div>
-        </aside>
+        <div
+          id="banner"
+          class="hidden rounded-full bg-emerald-500 px-4 py-2 text-sm font-semibold text-white"
+        ></div>
       </section>
 
-      <footer class="flex flex-wrap items-center justify-between gap-4 rounded-2xl bg-white p-5 shadow-md">
-        <button
-          type="button"
-          id="resetButton"
-          class="min-h-[44px] rounded-full border border-slate-200 bg-white px-5 text-sm font-semibold"
-        >
-          Reset
-        </button>
-        <p class="text-sm font-semibold text-slate-500">Hint: 도에서 시작해 미, 솔로 연결!</p>
+      <footer class="flex flex-col gap-3 rounded-2xl bg-white p-4 text-sm font-semibold text-slate-600 shadow">
+        <p id="statusText">드래그로 음을 연결하세요</p>
+        <div class="flex items-center gap-4">
+          <span class="rounded-full bg-slate-100 px-3 py-1 text-slate-900">I <span id="countI">0</span></span>
+          <span class="rounded-full bg-slate-100 px-3 py-1 text-slate-900">IV <span id="countIV">0</span></span>
+          <span class="rounded-full bg-slate-100 px-3 py-1 text-slate-900">V <span id="countV">0</span></span>
+        </div>
       </footer>
     </main>
 
     <script>
-      const board = document.querySelector(".board");
-      const flowLine = document.getElementById("flowLine");
+      const board = document.getElementById("board");
+      const nodesLayer = document.getElementById("nodesLayer");
+      const lineLayer = document.getElementById("lineLayer");
+      const activeLine = document.getElementById("activeLine");
+      const committedLines = document.getElementById("committedLines");
       const banner = document.getElementById("banner");
       const resetButton = document.getElementById("resetButton");
-      const notes = {
-        do: document.getElementById("note-do"),
-        mi: document.getElementById("note-mi"),
-        sol: document.getElementById("note-sol")
+      const soundToggle = document.getElementById("soundToggle");
+      const keySelect = document.getElementById("keySelect");
+      const statusText = document.getElementById("statusText");
+      const countEls = {
+        I: document.getElementById("countI"),
+        IV: document.getElementById("countIV"),
+        V: document.getElementById("countV")
       };
-      const order = ["do", "mi", "sol"];
+
+      const keyNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
+      const solfege = [
+        { id: "do", label: "도", color: "#38bdf8" },
+        { id: "re", label: "레", color: "#818cf8" },
+        { id: "mi", label: "미", color: "#f472b6" },
+        { id: "fa", label: "파", color: "#fb923c" },
+        { id: "sol", label: "솔", color: "#22c55e" },
+        { id: "la", label: "라", color: "#eab308" },
+        { id: "ti", label: "시", color: "#f43f5e" }
+      ];
+
+      const positions = {
+        do: { col: 1, row: 6 },
+        re: { col: 3, row: 6 },
+        mi: { col: 5, row: 6 },
+        fa: { col: 1, row: 3 },
+        sol: { col: 3, row: 3 },
+        la: { col: 5, row: 3 },
+        ti: { col: 6, row: 1 }
+      };
+
+      const chordRules = [
+        { id: "I", label: "으뜸화음 완성!", notes: ["do", "mi", "sol"] },
+        { id: "IV", label: "버금딸림화음 완성!", notes: ["fa", "la", "do"] },
+        { id: "V", label: "딸림화음 완성!", notes: ["sol", "ti", "re"] }
+      ];
+
+      const stages = [
+        { id: 1, size: 360, allowed: ["I"], target: 1 },
+        { id: 2, size: 440, allowed: ["I", "IV"], target: 2 },
+        { id: 3, size: 520, allowed: ["I", "IV", "V"], target: 3 }
+      ];
+
       const state = {
         isDrawing: false,
+        points: [],
         sequence: [],
-        points: []
+        counts: { I: 0, IV: 0, V: 0 },
+        key: "C",
+        soundOn: true,
+        stageIndex: 0
       };
+
       let audioContext;
+      let noteFrequencies = {};
+      let bannerTimeout;
+      let nodeElements = {};
+      const nodeRadius = 24;
+
+      function populateKeys() {
+        keyNames.forEach((name) => {
+          const option = document.createElement("option");
+          option.value = name;
+          option.textContent = name;
+          keySelect.append(option);
+        });
+        keySelect.value = state.key;
+      }
 
-      function getCenter(element) {
+      function getBoardMetrics() {
+        const rect = board.getBoundingClientRect();
+        const pad = parseFloat(getComputedStyle(board).getPropertyValue("--pad"));
+        const inner = {
+          left: pad,
+          top: pad,
+          width: rect.width - pad * 2,
+          height: rect.height - pad * 2
+        };
+        return { rect, inner };
+      }
+
+      function updateStageUI() {
+        const stage = stages[state.stageIndex];
+        board.style.maxWidth = `${stage.size}px`;
+        statusText.textContent = `Stage ${stage.id} · 허용 화음: ${stage.allowed.join(", ")} · 드래그로 음을 연결하세요`;
+        layoutNodes();
+      }
+
+      function layoutNodes() {
+        const { rect, inner } = getBoardMetrics();
+        lineLayer.setAttribute("viewBox", `0 0 ${rect.width} ${rect.height}`);
+        nodesLayer.innerHTML = "";
+        nodeElements = {};
+        solfege.forEach((note) => {
+          const node = document.createElement("div");
+          const { col, row } = positions[note.id];
+          const x = inner.left + (inner.width / 7) * col;
+          const y = inner.top + (inner.height / 7) * row;
+          node.className =
+            "note absolute flex h-12 w-12 items-center justify-center rounded-full text-sm font-bold text-white shadow";
+          node.style.backgroundColor = note.color;
+          node.style.left = `${x}px`;
+          node.style.top = `${y}px`;
+          node.dataset.note = note.id;
+          node.textContent = note.label;
+          nodesLayer.append(node);
+          nodeElements[note.id] = node;
+        });
+        updateNodeLabels();
+      }
+
+      function updateNodeLabels() {
+        // Key에 맞는 계이름으로 노드 텍스트를 변경
+        const keyIndex = keyNames.indexOf(state.key);
+        const intervals = [0, 2, 4, 5, 7, 9, 11];
+        solfege.forEach((note, idx) => {
+          const pitchIndex = (keyIndex + intervals[idx]) % 12;
+          const label = keyNames[pitchIndex];
+          if (nodeElements[note.id]) {
+            nodeElements[note.id].textContent = `${note.label}\n${label}`;
+            nodeElements[note.id].style.whiteSpace = "pre-line";
+            nodeElements[note.id].style.lineHeight = "1.1";
+          }
+        });
+      }
+
+      function getNodeCenters() {
+        const centers = {};
         const boardRect = board.getBoundingClientRect();
-        const rect = element.getBoundingClientRect();
+        nodesLayer.querySelectorAll(".note").forEach((node) => {
+          const rect = node.getBoundingClientRect();
+          centers[node.dataset.note] = {
+            x: rect.left - boardRect.left + rect.width / 2,
+            y: rect.top - boardRect.top + rect.height / 2
+          };
+        });
+        return centers;
+      }
+
+      function offsetPoint(from, to, distance) {
+        const dx = to.x - from.x;
+        const dy = to.y - from.y;
+        const length = Math.hypot(dx, dy) || 1;
         return {
-          x: rect.left - boardRect.left + rect.width / 2,
-          y: rect.top - boardRect.top + rect.height / 2
+          x: from.x + (dx / length) * distance,
+          y: from.y + (dy / length) * distance
         };
       }
 
-      function updateLine() {
-        const points = state.points.map((point) => `${point.x},${point.y}`).join(" ");
-        flowLine.setAttribute("points", points);
+      function buildLinePoints(pointer) {
+        // 라인은 점(노드) 내부를 지나가지 않도록 가장자리에서 시작/끝
+        const points = [];
+        const centersLookup = getNodeCenters();
+        const centers = state.sequence.map((note) => centersLookup[note]);
+        if (centers.length === 0) return [];
+        let safePointer = pointer;
+        const lastCenter = centers[centers.length - 1];
+        if (safePointer) {
+          const distanceToLast = Math.hypot(safePointer.x - lastCenter.x, safePointer.y - lastCenter.y);
+          if (distanceToLast <= nodeRadius) {
+            const prevCenter = centers.length > 1 ? centers[centers.length - 2] : { x: lastCenter.x + 1, y: lastCenter.y };
+            safePointer = offsetPoint(lastCenter, prevCenter, nodeRadius);
+          }
+        }
+        if (centers.length === 1) {
+          const edgeStart = offsetPoint(centers[0], safePointer, nodeRadius);
+          points.push(edgeStart, safePointer);
+          return points;
+        }
+        centers.forEach((center, idx) => {
+          const next = centers[idx + 1] || safePointer;
+          if (!next) return;
+          const startEdge = offsetPoint(center, next, nodeRadius);
+          points.push(startEdge);
+          if (idx === centers.length - 1) {
+            if (safePointer) {
+              points.push(safePointer);
+            }
+          }
+        });
+        for (let i = 0; i < centers.length - 1; i += 1) {
+          const prev = centers[i];
+          const nextCenter = centers[i + 1];
+          const endEdge = offsetPoint(nextCenter, prev, nodeRadius);
+          points.splice(i * 2 + 1, 0, endEdge);
+        }
+        return points;
       }
 
-      function resetFlow() {
-        state.isDrawing = false;
-        state.sequence = [];
+      function updateActiveLine(pointer) {
+        // active polyline: path 노드 좌표 + 현재 포인터
+        const points = buildLinePoints(pointer);
+        activeLine.setAttribute("points", points.map((point) => `${point.x},${point.y}`).join(" "));
+      }
+
+      function clearActiveLine() {
         state.points = [];
-        updateLine();
+        state.sequence = [];
+        updateActiveLine({ x: 0, y: 0 });
+        activeLine.setAttribute("points", "");
       }
 
-      function showBanner(message, tone) {
-        banner.textContent = message;
-        banner.classList.remove("hidden");
-        banner.classList.toggle("bg-blue-500", tone === "success");
-        banner.classList.toggle("bg-red-500", tone === "fail");
+      function commitLine(points, color) {
+        if (points.length < 2) return;
+        const polyline = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
+        polyline.setAttribute("fill", "none");
+        polyline.setAttribute("stroke", color);
+        polyline.setAttribute("stroke-width", "16");
+        polyline.setAttribute("stroke-linecap", "round");
+        polyline.setAttribute("stroke-linejoin", "round");
+        polyline.setAttribute("points", points.map((point) => `${point.x},${point.y}`).join(" "));
+        committedLines.append(polyline);
       }
 
-      function hideBanner() {
-        banner.classList.add("hidden");
+      function showBanner(message) {
+        banner.textContent = message;
+        banner.classList.remove("hidden");
+        clearTimeout(bannerTimeout);
+        bannerTimeout = setTimeout(() => {
+          banner.classList.add("hidden");
+        }, 1000);
       }
 
       function ensureAudioContext() {
+        if (!state.soundOn) return;
         if (!audioContext) {
           audioContext = new (window.AudioContext || window.webkitAudioContext)();
         }
         if (audioContext.state === "suspended") {
           audioContext.resume();
         }
       }
 
-      function playChord() {
+      function playTone(freq, duration, gainLevel = 0.2) {
+        // 단음 재생: sine, 0.12초
+        if (!state.soundOn) return;
         ensureAudioContext();
         if (!audioContext) return;
         const now = audioContext.currentTime;
-        const freqs = [261.63, 329.63, 392];
-        freqs.forEach((freq) => {
-          const osc = audioContext.createOscillator();
-          const gain = audioContext.createGain();
-          osc.type = "sine";
-          osc.frequency.value = freq;
-          gain.gain.value = 0;
-          osc.connect(gain);
-          gain.connect(audioContext.destination);
-          gain.gain.linearRampToValueAtTime(0.25, now + 0.02);
-          gain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
-          osc.start(now);
-          osc.stop(now + 0.4);
-        });
+        const osc = audioContext.createOscillator();
+        const gain = audioContext.createGain();
+        osc.type = "sine";
+        osc.frequency.value = freq;
+        gain.gain.value = 0;
+        osc.connect(gain);
+        gain.connect(audioContext.destination);
+        gain.gain.linearRampToValueAtTime(gainLevel, now + 0.02);
+        gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
+        osc.start(now);
+        osc.stop(now + duration + 0.05);
       }
 
-      function handleSuccess() {
-        showBanner("I chord 완성", "success");
-        playChord();
+      function playChord(notes) {
+        // 화음 재생: 3음 동시 0.45초
+        notes.forEach((note) => {
+          playTone(noteFrequencies[note], 0.45, 0.18);
+        });
       }
 
-      function handleFail(message) {
-        showBanner(message, "fail");
-        resetFlow();
+      function updateFrequencies() {
+        const keyIndex = keyNames.indexOf(state.key);
+        const baseMidi = 60 + keyIndex;
+        const intervals = [0, 2, 4, 5, 7, 9, 11];
+        noteFrequencies = {};
+        solfege.forEach((note, idx) => {
+          const midi = baseMidi + intervals[idx];
+          noteFrequencies[note.id] = 440 * Math.pow(2, (midi - 69) / 12);
+        });
+        updateNodeLabels();
       }
 
-      function handleStart(pointer) {
-        hideBanner();
-        ensureAudioContext();
-        const startCenter = getCenter(notes.do);
-        const distance = Math.hypot(pointer.x - startCenter.x, pointer.y - startCenter.y);
-        if (distance > 30) {
-          handleFail("도에서 시작해 주세요!");
-          return;
-        }
-        state.isDrawing = true;
-        state.sequence = ["do"];
-        state.points = [startCenter, pointer];
-        updateLine();
+      function checkChordCompletion() {
+        const uniqueNotes = new Set(state.sequence);
+        const stage = stages[state.stageIndex];
+        const allowed = chordRules.filter((rule) => stage.allowed.includes(rule.id));
+        const matches = allowed.filter((rule) => rule.notes.every((note) => uniqueNotes.has(note)));
+        if (matches.length === 0) return null;
+        return matches;
       }
 
-      function handleMove(pointer) {
-        if (!state.isDrawing) return;
-        state.points[state.points.length - 1] = pointer;
-        updateLine();
-        const expected = order[state.sequence.length];
-        if (!expected) return;
-        const targetCenter = getCenter(notes[expected]);
-        const distance = Math.hypot(pointer.x - targetCenter.x, pointer.y - targetCenter.y);
-        if (distance <= 30) {
-          state.sequence.push(expected);
-          state.points[state.points.length - 1] = targetCenter;
-          state.points.push(targetCenter);
-          updateLine();
-          if (state.sequence.length === order.length) {
-            state.isDrawing = false;
-            handleSuccess();
-          }
-        }
+      function updateCounters() {
+        countEls.I.textContent = state.counts.I;
+        countEls.IV.textContent = state.counts.IV;
+        countEls.V.textContent = state.counts.V;
       }
 
-      function handleEnd() {
-        if (!state.isDrawing) return;
-        state.isDrawing = false;
-        handleFail("도 → 미 → 솔 순서로 연결해요!");
+      function resetAll() {
+        clearActiveLine();
+        committedLines.innerHTML = "";
+        state.counts = { I: 0, IV: 0, V: 0 };
+        state.stageIndex = 0;
+        updateCounters();
+        banner.classList.add("hidden");
+        updateStageUI();
       }
 
       function getPointerPosition(event) {
         const rect = board.getBoundingClientRect();
         return {
           x: event.clientX - rect.left,
           y: event.clientY - rect.top
         };
       }
 
+      function findSnappedNode(pointer, centers) {
+        // 스냅 판정: 반경 22px 안이면 노드로 스냅
+        const radius = 22;
+        let snapped = null;
+        Object.entries(centers).forEach(([note, center]) => {
+          const distance = Math.hypot(pointer.x - center.x, pointer.y - center.y);
+          if (distance <= radius) {
+            snapped = { note, center };
+          }
+        });
+        return snapped;
+      }
+
+      function advanceStageIfNeeded() {
+        const stage = stages[state.stageIndex];
+        const total = state.counts.I + state.counts.IV + state.counts.V;
+        if (total >= stage.target && state.stageIndex < stages.length - 1) {
+          state.stageIndex += 1;
+          committedLines.innerHTML = "";
+          updateStageUI();
+          showBanner(`Stage ${stages[state.stageIndex].id} 시작!`);
+        }
+      }
+
+      function handleStart(event) {
+        // pointerdown이 노드 위에서 시작하면 드로잉 시작
+        const pointer = getPointerPosition(event);
+        const centers = getNodeCenters();
+        const snapped = findSnappedNode(pointer, centers);
+        if (!snapped) return;
+        ensureAudioContext();
+        state.isDrawing = true;
+        state.sequence = [snapped.note];
+        state.points = [snapped.center];
+        activeLine.setAttribute("stroke", solfege.find((note) => note.id === snapped.note).color);
+        updateActiveLine(pointer);
+        playTone(noteFrequencies[snapped.note], 0.12);
+        statusText.textContent = "연결 중...";
+      }
+
+      function handleMove(event) {
+        if (!state.isDrawing) return;
+        const pointer = getPointerPosition(event);
+        const centers = getNodeCenters();
+        updateActiveLine(pointer);
+        const snapped = findSnappedNode(pointer, centers);
+        if (snapped && !state.sequence.includes(snapped.note)) {
+          // 스냅된 노드를 path에 추가 + 단음 재생
+          state.sequence.push(snapped.note);
+          playTone(noteFrequencies[snapped.note], 0.12);
+        }
+      }
+
+      function handleEnd(event) {
+        if (!state.isDrawing) return;
+        state.isDrawing = false;
+        const pointer = event ? getPointerPosition(event) : { x: 0, y: 0 };
+        const points = buildLinePoints(pointer);
+        const matches = checkChordCompletion();
+        if (matches) {
+          matches.forEach((match) => {
+            state.counts[match.id] += 1;
+          });
+          updateCounters();
+          showBanner(matches[0].label);
+          playChord(matches[0].notes);
+          statusText.textContent = "화음 완성!";
+          advanceStageIfNeeded();
+        } else {
+          statusText.textContent = "드래그로 음을 연결하세요";
+        }
+        // 드래그 종료 시 라인을 확정하고 다음 입력을 위해 초기화
+        const color = matches ? "#22d3ee" : "#94a3b8";
+        commitLine(points, color);
+        clearActiveLine();
+      }
+
       board.addEventListener("pointerdown", (event) => {
         board.setPointerCapture(event.pointerId);
-        handleStart(getPointerPosition(event));
+        handleStart(event);
       });
 
       board.addEventListener("pointermove", (event) => {
-        handleMove(getPointerPosition(event));
+        handleMove(event);
       });
 
-      board.addEventListener("pointerup", () => {
-        handleEnd();
+      board.addEventListener("pointerup", (event) => {
+        handleEnd(event);
       });
 
-      board.addEventListener("pointerleave", () => {
-        handleEnd();
+      board.addEventListener("pointerleave", (event) => {
+        handleEnd(event);
       });
 
       resetButton.addEventListener("click", () => {
-        hideBanner();
-        resetFlow();
+        resetAll();
+      });
+
+      soundToggle.addEventListener("click", () => {
+        state.soundOn = !state.soundOn;
+        soundToggle.textContent = state.soundOn ? "Sound ON" : "Sound OFF";
       });
+
+      keySelect.addEventListener("change", (event) => {
+        state.key = event.target.value;
+        updateFrequencies();
+      });
+
+      window.addEventListener("resize", () => {
+        layoutNodes();
+      });
+
+      populateKeys();
+      updateFrequencies();
+      updateStageUI();
+      updateCounters();
     </script>
   </body>
 </html>
 
EOF
)
